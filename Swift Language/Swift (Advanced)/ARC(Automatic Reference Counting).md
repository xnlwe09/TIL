# ARC(Automatic Reference Counting)

## ARC(Automatic Reference Counting)란?

**Swift가 클래스 인스턴스의 메모리를 자동으로 관리해주는 시스템(자동 참조 카운트)**

클래스 인스턴스를 누가 몇 번 참조(reference)하고 있는지를 추적해서

더 이상 아무도 참조하지 않으면 메모리에서 제거(deinit)

= 참조 수가 0이 되면 ARC가 그 인스턴스를 메모리에서 해제해줌

## RC(Reference Count)란?

**인스턴스를 현재 누가 가르키고 있느냐 없느냐(참조하냐 안하냐)를 숫자로 표현한 것**

참조 계산 시점 : 컴파일 타임에 언제 참조되고 해제되는지 결정되어 런타임 때 그대로 실행됨

장점 : 개발자가 참조 해제 시점을 파악할 수 있고 런타임 시점에 추가 리소스가 발생하지 않음

단점 : 순환 참조가 발생 시 영구적으로 메모리가 해제되지 않을 수 있음

**RC의 숫자세는 기준**

<aside>

### Count Up

- 인스턴스의 주소값을 변수에 할당할 때
- 인스턴스 생성(새로운 변수 대입)
- 기존 인스턴스 다른 변수에 대입
</aside>

<aside>

### Count Down

- 인스턴스를 가리키던 변수가 메모리에서 해제되었을 때
- nil이 지정되었을 때
- 변수에 다른 값을 대입한 경우
- 프로퍼티의 경우 속해 있는 클래스 인스턴스가 메모리에서 해제될 때
</aside>

## ARC의 메모리 관리법

Reference Count(참조 횟수)를 계산하여 참조 횟수가 0이면

더 이상 사용하지 않는 메모리라 생각하여 해제

(ARC는 클래스 인스턴스가 더 이상 필요하지 않을 때 메모리를 자동으로 해제함)

기본적으로 클래스의 객체를 가리키는 각각의 reference는 강한 참조

최소한 하나의 강한 참조가 있는 이상 객체의 메모리는 해제되지 않음

만약 객체에 대한 강한 참조가 존재하지 않는다면 메모리에서 해제됨

## 참조 키워드 종류

<aside>

### 📍Strong(강한 참조)

인스턴스의 주소값이 변수에 할당 될 때 RC가 증가하면 강한 참조

보통 참조의 기본값이 강한 참조라고 볼 수 있음

</aside>

<aside>

### 📍Weak(약한 참조)

인스턴스를 참조할 시 RC를 증가시키지 않음

인스턴스가 메모리에서 해제된 경우 자동으로 nil이 할당되어 메모리가 해제됨

Weak는 무조건 Optional 타입의 변수여야 하며,

순환 참조를 일으키는 프로퍼티 앞에 weak 키워드를 붙여주면 됨

</aside>

<aside>

### 📍Unowned(미소유 참조)

weak와 같이 강한 순환 참조를 해결할 수 있고, reference count를 증가시키지 않음

하지만 인스턴스를 참조하는 도중에 해당 인스턴스가 메모리에서 사라질 일이 없다고 확신함

→ 참조하던 인스턴스가 만약 메모리에서 해제된 경우 nil을 할당 받지 못하고

해제된 메모리 주소값을 계속 가리킴

그래서 다른 인스턴스의 수명이 동일하거나 같을 때 사용

= unowned로 참조하는 대상이 자기보다 절대 먼저 해제되지 않는다는 보장이 있을 때

미소유 참조로 선언된 인스턴스가 해제되었는데 접근하게 되면 런타임 에러 발생 / 크래시남

</aside>

## weak self

**클로저가 self를 약하게 캡쳐하게 해서 순환 참조를 방지하는 방법**

<aside>

- 클로저 내부에서 self를 사용하면 클로저가 self를 강하게 캡쳐하게 됨
- 근데 self도 그 클로저를 강하게 참조하고 있으면 순환 참조 발생
- 이때 `weak self`를 사용하면 클로저가 self를 약하게 캡쳐함
- 그래서 참조 카운트가 증가하지 않아서 순환 참조도 안 생김!!

- 최종적으로 클로저가 존재하더라도 self가 다른 곳에서 더 이상 필요 없으면 ARC가 해제할 수 있게 됨
- self 해체 → 클로저 내부에서의 self는 자동으로 nil
</aside>

그니까 weak self를 쓰면 한 객체가 참조 카운트에 포함안되게 해서 필요없을 땐 해제할 수 있다는 거임용

```swift
// 클로저 기본 구조
{ (매개변수) -> 반환타입 in // in을 기준으로 앞은 Closure Head
    실행할 코드 // 뒤는 Closure Body
}
```

```swift
{ [weak self] (매개변수) -> 반환타입 in
    // 실행할 코드
}
```

```swift
someFunction { [weak self] in
    // weak self로 캡처
    self?.doSomething()  // self는 다른 참조가 사라지면 nil이 될 수 있으니까 옵셔널인 거임
}
```

```swift
someAsyncFunction { [weak self] result in
    guard let self = self else { return }  // self를 안전하게 언래핑
    
    // 이제 self를 바로 사용 가능
    processResult(result)
    updateUI()
    saveData()
}

// 이건 사실 잘 모ㅡ르겟어요 ㅜㅠㅠ
```