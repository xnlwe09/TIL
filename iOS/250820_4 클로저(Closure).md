# 클로저(Closure)

생성일: 2025년 8월 20일 오후 10:26

## 클로저(Closure)란?

**주변 문맥으로부터 값을 캡처할 수 있는 코드 블록**

클로저(Closure)엔 Named Closure와 Unnamed Closure가 있는데

Named Closure는 흔히 우리가 사용하는 이름있는 함수 (이것도 클로저지만 클로저라고 안부를 뿐임)

Unnamed Closure는 이름을 붙이지 않고 사용하는 (func 키워드도 없이)

```swift
let closure = { print("Juhui") }
```

이런 형태의 익명함수

⇒ 보통 클로저(Closure)라고 하면 위 같은 익명함수(Unnamed Closure)를 말함

- 함수 : 이름이 있고 func 키워드로 정의
- 클로저 : 이름이 없어도 되고, 변수나 상수에 담아서 사용 가능

⇒ 클로저는 함수의 인자로도 자주 사용됨

## 클로저 표현식 (기본 구조)

```swift
{ (매개변수) -> 반환타입 in // in을 기준으로 앞은 Closure Head
    실행할 코드 // 뒤는 Closure Body
}
```

### ex) 두 정수를 받아 합을 반환하는 클로저(Closure)

```swift
let sumClosure: (Int, Int) -> Int = { (a, b) in
    return a + b
}

let result = sumClosure(3, 5) // result = 8
```

## 클로저(Closure) 문법 축약

<aside>

### 📍return 생략

단일 표현식일 경우 return 생략 가능

```swift
let sumClosure: (Int, Int) -> Int = { (a: Int, b: Int) in a + b }
```

</aside>

<aside>

### 📍파라미터 타입 생략

이미 왼쪽에서 (Int, Int) -> Int 타입을 지정했으니 a, b 타입 표시는 생략해도 됨

```swift
let sumClosure: (Int, Int) -> Int = { (a, b) in a + b }
```

</aside>

<aside>

### 📍파라미터 이름 생략

클로저 안에서 첫 번째 인자는 $0, 두 번째 인자는 $1로 자동 접근 가능

```swift
let sumClosure: (Int, Int) -> Int = { $0 + $1 }
```

</aside>

### 최종축약

```swift
let sumClosure: (Int, Int) -> Int = { $0 + $1 }
let result = sumClosure(3, 5) // 8
```

+ 파라미터가 하나인 경우 ()도 생략 가능 = ()에 값이 아무것도 없다면 생략

## **트레일링 클로저(Trailing Closure)**

<aside>

함수의 마지막 파라미터가 클로저일 때,

이를 파라미터 값 형식이 아닌 함수 뒤에 붙여 작성하는 문법

이때, Argument Label은 생략된다

```swift
// 원래 형식
doSomething(closure: { () -> () in
    print("Hello!")
}) // 호출 구문 () 안에 클로저가 있음 = Inline Closure

// Trailing Closure
doSomething () **{ () -> () in
    print("Hello!")
}** // 끝에 클로저가 있음
```

파라미터가 클로저 하나일 경우엔 호출구문인 ()도 생략 가능

```swift
doSomething { () -> () in
    print("Hello!")
}
```

</aside>

## 캡쳐(Capture)

<aside>

클로저는 외부 변수를 기억하고 사용할 수 있음

```swift
func doSomething() {
    var message = "주희 is iOS Developer"
 
    //클로저 범위 시작
    
    var num = 10
    let closure = { print(num) }
 
    //클로저 범위 끝
    
    print(message)
}

```

클로저(Closure)에서 num이라는 외부 변수를 사용하기 때문에

num의 값을 클로저 내부적으로 저장하고 있음

→ 클로저에 의해 num의 값이 **캡쳐(Capture)** 되었다고 함

</aside>

<aside>

### 📍Reference Capture

클로저(Closure)는 Value/Reference 타입에 관계 없이 Reference Capture

(값 타입을 저장하려면 값을 복사해서 전달해야될텐데 클로저는 그렇지 않고

타입에 관계없이 캡쳐하는 값들을 참조함)

⇒ 그래서 클로저 외부에서 값이 바뀌면 클로저 내부 값도 바뀌고

반대로 클로저 내부에서 값이 바뀌어도 클로저 외부에 있는 값도 바뀜!

```swift
func doSomething() {
    var num: Int = 0
    print("num #1 = \(num)")
    
    let closure = {
        num = 20
        print("num #3 = \(num)")
    }
    
    closure()
    print("num #2 = \(num)")
}
 
```

</aside>

<aside>

### 📍클로저의 캡쳐 리스트(Capture Lists)

Value Type으로 캡쳐하고 싶을 때 사용할 수 있는 방법

**클**로저의 시작인 { 의 바로 옆에  []를 이용해 캡쳐할 멤버를 나열 (이때 in 키워드도 꼭 함께 작성)

```swift
let closure { [num, num2] in
```

Value Type의 경우, Value Capture 하고 싶은 변수를 위 같이 리스트로 명시

```swift
func doSomething() {
    var num: Int = 0
    print("num check #1 = \(num)")
    
    let closure = { [num] in
        print("num check #3 = \(num)")
    }
    
    num = 20
    print("num check #2 = \(num)")
    closure()
}
```

근데 이건 상수로 캡쳐돼서 클로저 내부에서 값을 못 바꿈

</aside>